# -*- coding: utf-8 -*-
"""FuNNgi.ipynb

Automatically generated by Colaboratory.


"""

# Commented out IPython magic to ensure Python compatibility.
from tensorflow.keras.models import Sequential #библиотека с открытым исходным кодом, помогающая разрабатывать и обучать модели машинного обучения
from tensorflow.keras.layers import Dense, Dropout
from tensorflow.keras import utils
#from tensorflow.keras.preprocessing import image
import numpy as np
import matplotlib.pyplot as plt
#from PIL import Image
# %matplotlib inline 
import pandas as pd

"""## Подготовка данных для обучения сети

**Формирование кадров тестовых и тренировочных данных из входных файлов**
"""

Traindf=pd.read_excel('Train.xlsx')
Testdf=pd.read_excel('Test.xlsx')

Traindf.head()

"""**Подготовка гистограмм тренировочного и тестовых наборов**"""

TraindfX=Traindf.iloc[:,3:130] #выбрать все ряды, выбрать колонки с четвертой по 131 https://stackoverflow.com/questions/56311638/how-how-iloc-1-works-can-any-one-explain-1-params
TestdfX=Testdf.iloc[:,3:130]
TraindfX.head()
x_train=TraindfX.to_numpy()
x_test=TestdfX.to_numpy()

x_train[2]

"""**Подготовка меток (гриб или нет) для тренировочного и тестовых наборов**"""

TraindfY=Traindf.iloc[:,2]
TestdfY=Testdf.iloc[:,2]
TraindfY.head()
y_train=TraindfY.to_numpy()
y_test=TestdfY.to_numpy()

"""**Количество меток в тренировочном наборе**"""

len(y_train)

y_test

"""**Преобразование меток в формат one hot encoding**"""

y_train = utils.to_categorical(y_train, 2) #Converts a class vector (integers) to binary class matrix.

y_test = utils.to_categorical(y_test, 2)

"""**Правильный ответ в формате one hot encoding**"""

print(y_train[20])

"""## Построение и обучение нейронной сети

**Построение последовательной модели**
"""

# Создаем последовательную модель
model = Sequential()
# Входной полносвязный слой, 128 нейронов, 127 входа в каждый нейрон
model.add(Dense(128, input_dim=127, activation="relu")) #способ активации  Relu, установка стартовых коэффициентов
# Выходной полносвязный слой, 2 нейрона (гриб=1 или нет=0)
model.add(Dense(2, activation="softmax")) #способ активации  softmax, установка стартовых коэффициентов

"""**Компиляция нейронной сети**"""

model.compile(loss="categorical_crossentropy", optimizer="adam", metrics=["accuracy"])

print(model.summary())

"""**Обучение нейронной сети**"""

history = model.fit(x_train, y_train, 
                    batch_size=10, 
                    epochs=150,
                    validation_split=0.2,
                    verbose=1)

fig, ax = plt.subplots(figsize=(12, 6))
ax.plot(history.history['accuracy'], color='blue', label='The percentage of correct answers in the training set')
ax.plot(history.history['loss'], color='red', label='Training error')
plt.legend()
plt.ylim(0,1)
plt.show()

"""## Оценка качества обучения

**Проверка качества работы на тестовом наборе данных**
"""

scores = model.evaluate(x_test, y_test, verbose=1)

print("Доля правильных ответов на тестовых данных, в процентах:", round(scores[1] * 100, 4))

classes = ['Not_Fungi','Yep_Fungi']

"""**Формирование кадра выходных данных**"""

P_Not=[]
P_Yep=[]
NN_Ch=[]
for Row in range(len(Testdf)):
  x = x_test[Row]
  x = np.expand_dims(x, axis=0) ##Меняем размерность изображения и нормализуем его
  prediction = model.predict(x) ##Запускаем распознавание
  P_Not.append(prediction[0][0])
  P_Yep.append(prediction[0][1])
  NN_Ch_ind=np.argmax(prediction[0])
  NN_Ch.append(classes[NN_Ch_ind])

prediction[0][0]

Resultdf=Testdf.iloc[:,1:3]
Resultdf.insert(2,'NN_Ch',NN_Ch)
Resultdf.insert(3,'P_Yep',P_Yep)
Resultdf.insert(4,'P_Not',P_Not)
Resultdf.head(10)

"""**Формирование выходного файла**"""

Resultdf.to_excel('Result.xlsx')

w=model.get_weights()
max(w[0][0])

from matplotlib.cbook import index_of
for R in w[0]:
  print(max(R),np.where(R==max(R)))

w[0][0]

